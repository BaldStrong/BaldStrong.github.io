{"pages":[],"posts":[{"title":"Android Studio自带模拟器联网","text":"利用Android Studio自带的模拟器联网。 Android Studio自带的模拟器本身默认是不能上网的，因为默认DNS为10.0.2.3，使用这个DNS是不能上网的。 网上很多帖子已经给出了解决办法，但是会遇到下面这种情况： 通过继续查询得知：通过shell命令设置（获取）IP、网关、dns信息，需要获取root权限。 下面给出打开Android Studio自带的模拟器联网功能的完整步骤（亲测可行）：首先把模拟器打开，然后需要把SDK文件夹下的platform-tools添加到系统变量中，至于怎么添加系统变量，请自行百度。 怎么检查自己是否添加成功呢，在cmd中输入：adb shell 回车，如果是下图的话代表添加成功。如果成功的话，输入exit即可退出adb。 重点来了，进入到cmd后，需要输入adb root 将模拟器root一下，才能更改DNS。然后再输入adb shell。 接下来输入getprop获取模拟器系统属性。找到[net.eth0.dns1]这一项，发现后面为10.0.2.3，接下来我们输入setprop net.eth0.dns1 192.168.1.1.后面的ip也可为其他，不过我没尝试。 网上很多帖子是[net.dns1]，不过我的模拟器上面dns1前面有eth0，这个大家根据自己的模拟器情况决定。 然后打开模拟器的数据连接。即可使用模拟器的谷歌浏览器上网。 PS：我记得我之前root过一次，但好像是每次打开电脑要修改模拟器重要配置的话就需要root，总之一句话，root就完事了。","link":"/2018/09/08/Android%20Studio%E8%87%AA%E5%B8%A6%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%81%94%E7%BD%91/"},{"title":"HTML学习代码记录","text":"初学HTML，由于是看视频学习，所以遗忘较快，故通过在博客里面记录代码来使自己加注释，从而复习语法知识。 1.列表与链接标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;base target=&quot;_blank&quot; /&gt; &lt;!-- base标签可以设置整个页面链接的打开方式 --&gt;&lt;/head&gt;&lt;body&gt; &lt;del&gt;1800&lt;/del&gt; &lt;!--删除线--&gt; &amp;lt;p&amp;gt;&amp;#60; &lt;!-- 在网页中显示&lt;p&gt; --&gt; &lt;img src=&quot;123.png&quot; title=&quot;这是我的手机&quot; width=&quot;50&quot; border=&quot;3&quot; /&gt; &lt;img src=&quot;121 3.png&quot; alt=&quot;这是我的手机&quot; /&gt; &lt;!-- src：图片路径 alt：图片不能显示时的替换文本 title：鼠标悬停在图片上时显示的内容 --&gt; &lt;hr width=&quot;666&quot; color=&quot;red&quot; /&gt; &lt;!-- hr：水平线 --&gt; &lt;ins&gt;下划线&lt;/ins&gt; &lt;!--下划线--&gt; &lt;h1&gt; ···链接标签 a即anchor[锚]的缩写&lt;/h1&gt; &lt;h2&gt;友情链接&lt;/h2&gt; &lt;a href=&quot;http:/www.baidu.com&quot;&gt;百度一下&lt;/a&gt; &lt;a href=&quot;http:/www.sina.com&quot; target=&quot;_blank&quot;&gt;新浪&lt;/a&gt; &lt;!-- target：用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值，blank为在新窗口中打开方式。PS：此处与head处base冲突,则以此处为准 --&gt; &lt;h1&gt;···锚点定位&lt;/h1&gt; &lt;a href=&quot;#live&quot; target=&quot;_self&quot;&gt;3 个人生活&lt;/a&gt; &lt;!-- 1.使用“a href=”#id名&gt;“链接文本&quot;&lt;/a&gt;创建链接文本。 --&gt; h1 id=&quot;live&quot;&gt;个人生活&lt;/h1&gt; &lt;!-- 2.使用相应的id名标注跳转目标的位置。 --&gt; &lt;h1&gt;···无序列表&lt;/h1&gt; &lt;!-- &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 --&gt; &lt;ul&gt; &lt;li&gt;垃&lt;/li&gt; &lt;li&gt;带&lt;/li&gt; &lt;li&gt;12&lt;/li&gt; &lt;li&gt; &lt;h3&gt;水果蔬菜&lt;/h3&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;···有序列表&lt;/h1&gt; &lt;ol&gt; &lt;li&gt;哦国&lt;/li&gt; &lt;li&gt;英国&lt;/li&gt; &lt;li&gt;中国&lt;/li&gt; &lt;li&gt;俄罗斯&lt;/li&gt; &lt;/ol&gt; &lt;!-- 自定义列表：定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。--&gt; &lt;dl&gt; &lt;!--dd围绕dt，dd介绍dt--&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;昌平&lt;/dd&gt; &lt;dd&gt;通州&lt;/dd&gt; &lt;/dl&gt;&lt;/body&gt;&lt;/html&gt; 2.表格标签123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表格练习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table width=&quot;300&quot; height=&quot;200&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot;&gt; &lt;!-- cellpadding：设置单元格与单元格边框之间的空白间距 cellspacing：设置单元格内容与单元格边框的空白间距 align:设置表格在页面中的水平对齐方式 --&gt; &lt;caption&gt;我要一个表格&lt;/caption&gt; &lt;thead&gt; &lt;!-- thead 用于定义表格的头部 --&gt; &lt;tr&gt; &lt;!-- tr 用于定义表格中的一行，必须嵌套在 table /table标签中 --&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;!--th 表头标签--&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- tbody：用于定义表格的主体 --&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;!-- td：用于定义单元格，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列 --&gt; &lt;td&gt;男&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;18&lt;/td&gt; &lt;!-- 跨行合并：rowspan 跨列合并：colspan --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/html&gt; &lt;/body&gt; 3.input控件123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单练习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot; /&gt; &lt;!-- input为单标签 value：input控件中的默认文本值--&gt; &lt;!-- &lt;input /&gt; --&gt; 用户名：&lt;input type=&quot;text&quot; value=&quot;用户名&quot; /&gt;&lt;br /&gt; &lt;!-- 这是一个文本框 --&gt; &lt;!-- 注释快捷键ctrl+/ --&gt; 密&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; maxlength=&quot;6&quot; /&gt;&lt;br /&gt; &lt;!-- 这是一个密码框 --&gt; 性&amp;nbsp;&amp;nbsp;别：女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; /&gt; 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 未知&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;&lt;br /&gt; &lt;!-- 通过相同的name把两个单选放置同一空间，这样只能选一个 --&gt; 爱&amp;nbsp;&amp;nbsp好：足球&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; 篮球&lt;input type=&quot;checkbox&quot; /&gt;乒乓球&lt;input type=&quot;checkbox&quot; /&gt;&lt;br /&gt; &lt;!-- 复选框 --&gt; 搜索&lt;input type=&quot;button&quot; value=&quot;搜索&quot;/&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交表单&quot;/&gt;&lt;br /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置表单&quot;/&gt;&lt;br /&gt; &lt;input type=&quot;image&quot; src=&quot;1.png&quot;/&gt;&lt;br /&gt; &lt;!-- 图像按钮 --&gt; &lt;input type=&quot;file&quot; /&gt; &lt;!-- 上传文件 --&gt;&lt;/body&gt;&lt;/html&gt; 4.表单-视频标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;label标签的使用&lt;/h3&gt; &lt;label&gt;输入账号：&lt;input type=&quot;text&quot; /&gt;&lt;/label&gt; &lt;!-- 用label直接包裹input ：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点--&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; &lt;form action=&quot;xxx.php&quot; method=&quot;get&quot; name=&quot;userMessage&quot;&gt; &lt;!-- form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器 --&gt; &lt;!-- 1. Action：在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 2. method：用于设置表单数据的提交方式，其取值为get或post。 3. name：用于指定表单的名称，以区分同一个页面中的多个表单。 --&gt; 留言板： &lt;textarea cols=&quot;10&quot; rows=&quot;10&quot;&gt;请输入内容&lt;/textarea&gt; &lt;!-- 如果需要输入大量的信息，就需要用到此标签。通过textarea控件可以轻松地创建多行文本输入框 --&gt;&lt;!-- 选择框 --&gt; 籍贯： &lt;select&gt; &lt;!-- 至少应包含一对option&gt;&lt;/option&gt;。 --&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;广州&lt;/option&gt;&lt;!-- 使用seleced默认选项 --&gt; &lt;/select&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;/form&gt; &lt;audio src=&quot;AAAAAAA张悬-关于我爱你.mp3&quot; autoplay controls=&quot;&quot; loop=&quot;&quot;&gt;&lt;/audio&gt; &lt;audio controls=&quot;&quot; autoplay=&quot;&quot;&gt; &lt;!-- 兼容性解决办法 --&gt; &lt;source src=&quot;123.mp3&quot; type=&quot;&quot;&gt; &lt;source src=&quot;123.ogg&quot; type=&quot;&quot;&gt; &lt;/audio&gt; &lt;video src=&quot;The Smart Home of Tomorrow HD - YouTube.mp4&quot; autoplay=&quot;&quot; controls=&quot;&quot;&gt;&lt;/video&gt; &lt;!-- autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 --&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/05/04/HTML%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/"},{"title":"Linux笔记","text":"Linux笔记 命令总结123456789101112131415161718192021222324252627282930cd - #在上一次的工作目录和当前目录来回切换cat filename #查看文件内容head filename #查看文件前几行，可以用head -n 9 filename看前9行tail filename #查看文件后几行ls -a #列出所有文件，包括隐藏文件ls -F #列出文件夹ls -l #列出文件属性，包括权限，属组，时间等等，类似于视窗的详细列表-ld #列出所在文件夹的属性，详细列表【常用ls -l 和 ls -afl】locate #查找全盘的文件内容，用法如下：locate *softname*.tar.gz #所有包括文件路径中包含softname，并以tar.gz结尾都会被列出来who #查看谁在线rm -rf foldername #强制删除文件夹/文件mv path/file file2 #把路径path下的文件file移动到当前文件夹，并命名为file2，可以用于重命名【补：可以用于重命名】mv -i path/file file2 #如果当前文件夹下面有file2，会提示是否覆盖mv -b path/file file2 #如果当前文件夹下面有file2，把新文件变成~file2cp pathfile file2 #把路径path下的文件file拷贝到当前文件夹，并命名为file2touch filename #新建一个文件echo hello,world &gt; hello.txt #新建hello.txt文件并输出hello,world #当然，对于实际编写大量程序的时候用这个是很麻烦的，有别的类似文本编辑器一样的东西辅助编辑，如gedit，UE等(很久以后补充了这一段)cat &gt;file.f90&lt;&lt;EOF #新建file并打开等待输入，直到遇到EOF跳出此文件，执行后如下：&gt; print,”test file”&gt; end&gt; EOF #结束输入，文件file中写入两行内容ls查看时，不同颜色表示不同文件类型：蓝色(文件夹)、黑色(普通文本)、绿色(可执行文件)、淡蓝色(快捷方式)、红色(警告文件有问题)、淡红色(压缩包) 软件12345678910111213htop：Linux性能监控热键：u ：具有过滤功能，能显示用户指定用户的进程s ：选定某个进程后，使用该命令可以跟踪该进程所发起的系统调用l ：选定某个进程后，使用该命令可以显示该经常打开的文件有那些t ：直接使用该命令可以显示进程的层级机构a ：使用该命令可以设定某个进程的cpu亲缘性k ：使用该命令可以结束某个指定进程h ：该工具还有众多功能，使用该命令可以获取该工具其他帮助信息标识：RES：进程占用的物理内存值SHR：进程占用的共享内存值TIME+：该进程启动后占用的总的CPU时间 #配置环境变量 12345678910111213141516171819202122232425262728293031可用 export 命令查看PATH值单独查看PATH环境变量，可用：echo PATH添加PATH环境变量(临时)，可用：export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:PATHexport PATH=PATH:/XXX 但是退出当前终端后就失效export 路径PATH=&quot;路径”(“PATH= PATH:路径”**)**永久添加环境变量(影响当前用户)vim ~/.bashrc export PATH=“/opt/STM/STLinux-2.3/devkit/sh4/bin:PATH”永久添加环境变量(影响所有用户)vim /etc/profile在文档最后，添加:export PATH=&quot;/opt/STM/STLinux-2.3/devkit/sh4/bin:PATH&quot;保存，退出，然后运行：source /etc/profile（source也可换成“.”）LD_LIBRARY_PATH是Linux环境变量名，该环境变量主要用于指定查找共享库（动态链接库）时除了默认路径之外的其他路径。当执行函数动态链接.so时，如果此文件不在缺省目录下‘/lib’ and ‘/usr/lib’.那么就需要指定环境变量LD_LIBRARY_PATH logout退出服务器Linux中profile、bashrc、bash_profile之间的区别和联系/etc/profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并/etc/profile.d目录的配置文件中搜集shell的设置./etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bashshell被打开时,该文件被读取.~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ~/.bashrc: 该文件包含专用于你的bashshell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.~/.bash_logout: 当每次退出系统(退出``bashshell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是”父子”关系. /etc/profile ** : 此文件为系统每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.所以如果你有对/etc/profile有修改的话必须得重启你的修改才会生效**，此修改对每个用户都生效。 /etc/bashrc : 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.当被修改后，不用重启只需要打开一个新的 bash 即可生效。 **/etc/profile.d/**：此文件夹里是除/etc/profile之外其他的”application-specific startup files”。英文描述为”The /etc/profile file sets the environment variables at startup of the Bash shell. The /etc/profile.d directory contains other scripts that contain application-specific startup files, which are also executed at startup time by the shell.” 同时，这些文件”are loaded via /etc/profile which makes them a part of the bash “profile” in the same way anyway.” 因此可以简单的理解为是/etc/profile的一部分，只不过按类别或功能拆分成若干个文件进行配置了（方便维护和理解）。 文件的执行顺序为：当登录Linux时，首先启动/etc/environment和/etc/profile，然后启动当前用户目录下的/.bash_profile，执行此文件时一般会调用/.bashrc文件，而执行/.bashrc时一般会调用/etc/bashrc，最后退出shell时，执行/.bash_logout。简单来说顺序为： （登录时）/etc/environment –&gt; /etc/profile(以及/etc/profile.d/里的文件) –&gt; /.bash_profile –&gt; （打开shell时）/.bashrc –&gt; /etc/bashrc –&gt; （退出shell时）~/.bash_logout 查看版本：gcc –version ##编译器 cc、gcc、g++、CC 的区别 cc来自于Unix的c语言编译器，是 c compiler 的缩写。gcc来自Linux世界，是GNU compiler collection 的缩写，注意这是一个编译器集合，不仅仅是c或c++。 gcc 是GNU Compiler Collection，原名为Gun C语言编译器，因为它原本只能处理C语言，但gcc很快地扩展，包含很多编译器（C、C++、Objective-C、Ada、Fortran、 Java），可以说gcc是GNU编译器集合。 g++ 是C++编译器。 cc 是 Unix系统的 C Compiler，一个是古老的 C 编译器。而 Linux 下 cc 一般是一个符号连接，指向 gcc；可以通过 ls -l /usr/bin/cc 来简单察看，该变量是 make 程序的内建变量，默认指向 gcc 。 cc 符号链接和变量存在的意义在于源码的移植性，可以方便的用 gcc 来编译老的用cc编译的Unix软件，甚至连 makefile 都不用改在，而且也便于 Linux 程序在 Unix下 编译。 CC 则一般是 makefile 里面的一个名字标签，即宏定义，表示采用的是什么编译器（如：CC = gcc）。 -I与-L选项1234567891011121314151617181920212223242526272829303132333435 -I dir ：使用#include&lt;&gt;,gcc默认目录shi &quot;/usr/include&quot;，如果使用#include&lt;my.h&gt;则找不到my.h文件，因此要通过“-I dir”参数来指定包含的头文件my.h的位置： gcc 1-3.c -o 1-3 -I /root (假设文件my.h存放在/root下)把＃include&lt;my.h&gt;改为#include&quot;my.h&quot;就不需要“-I dir”参数也能正确编译了。 -L dir： -L dir与-I dir 功能类似，能够在库文件的搜索路径列表中添加dir目录。如果一个程序用到了目录/root/lib下的一个动态库libsunq.so，因为-L dir指定的是路径而没有指定文件，则需要用到 -llibarry参数，它可以指定gcc去寻找libsunq.so。在linux下的库文件命名规定必须以lib三个字母开头，因此，在用“-I”指定连接库文件时可以省去lib三个字母，即，-llibsunq有时可以写成“-lsunq”: gcc 1-3.c -o 1-3 -L /root/lib -lsunq-l参数和-L参数-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名，那么库名跟真正的库文件名有什么关系呢？就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，把库文件名的头lib和尾.so去掉就是库名了。好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫libtest.so，那么我们只要把libtest.so拷贝到/usr/lib里，编译时加上-ltest参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与libtest.so配套的头文件）。放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目录里，这时我们只用-l参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find -lxxx”，也就是链接程序ld在那3个目录里找不到libxxx.so，这时另外一个参数-L就派上用场了，比如常用的X11的库，它放在/usr/X11R6/lib目录下，我们编译时就要用-L/usr/X11R6/lib -lX11参数，-L参数跟着的是库文件所在的目录名。再比如我们把libtest.so放在/aaa/bbb/ccc目录下，那链接参数就是-L/aaa/bbb/ccc -ltest 查看CPU12345678910111213141516171819# 总核数 = 物理CPU个数 X 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数# 查看物理CPU个数cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l# 查看每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq# 查看所有逻辑CPU（线程）的个数cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l# 查看GPU型号cat /proc/cpuinfo | grep 'model name' |uniq首先要明确物理cpu个数、核数、逻辑cpu数的概念1.物理cpu数：主板上实际插入的cpu数量，可以数不重复的 physical id 有几个（physical id）2.cpu核数：单块CPU上面能处理数据的芯片组的数量，如双核、四核等 （cpu cores）3.逻辑cpu数：一般情况下，逻辑cpu=物理CPU个数×每颗核数，如果不相等的话，则表示服务器的CPU支持超线程技术（HT：简单来说，它可使处理器中的1 颗内核如2 颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能，此时逻辑cpu=物理CPU个数×每颗核数x2） 查看设备信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 uname -a # 查看内核/操作系统/CPU信息# lsb_release -a # 查看操作系统版本 (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb) # cat /proc/cpuinfo # 查看CPU信息# hostname # 查看计算机名# lspci -tv # 列出所有PCI设备# lsusb -tv # 列出所有USB设备# lsmod # 列出加载的内核模块# env # 查看环境变量**资源**# free -m # 查看内存使用量和交换区使用量# df -h # 查看各分区使用情况# du -sh &lt;目录名&gt; # 查看指定目录的大小# grep MemTotal /proc/meminfo # 查看内存总量# grep MemFree /proc/meminfo # 查看空闲内存量# uptime # 查看系统运行时间、用户数、负载# cat /proc/loadavg # 查看系统负载**磁盘和分区**# mount | column -t # 查看挂接的分区状态# fdisk -l # 查看所有分区# swapon -s # 查看所有交换分区# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)# dmesg | grep IDE # 查看启动时IDE设备检测状况**网络**# ifconfig # 查看所有网络接口的属性# iptables -L # 查看防火墙设置# route -n # 查看路由表# netstat -lntp # 查看所有监听端口# netstat -antp # 查看所有已经建立的连接# netstat -s # 查看网络统计信息**进程**# ps -ef # 查看所有进程# top # 实时显示进程状态**用户**# w # 查看活动用户# id &lt;用户名&gt; # 查看指定用户信息# last # 查看用户登录日志# cut -d: -f1 /etc/passwd # 查看系统所有用户# cut -d: -f1 /etc/group # 查看系统所有组# crontab -l # 查看当前用户的计划任务**服务**# chkconfig --list # 列出所有系统服务# chkconfig --list | grep on # 列出所有启动的系统服务 Linux下的tar压缩解压缩命令详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889**压缩**tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linuxzip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux**解压**tar -xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar -xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zippigz是支持并行的gzip,默认用当前逻辑cpu个数来并发压缩，无法检测个数的话，则并发8个线程安装pigz$sudo apt install pigz1打包$tar --use-compress-program=pigz -cvpf package.tgz ./package1解包#tar --use-compress-program=pigz -xvpf package.tgz -C ./package1tar –use-compress-program=pigz表示指定pigz来进行打包c表示create创建 x表示extract解压 v表示verbose详细 f表示指定压缩文件 C表示指定目录-cvpf package.tgz ./ 表示将./package目录打包为package.tgz-xvpf package.tgz -C ./表示将package.tgz解压到./package目录下tar**-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件以上这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。\\# tar -cf all.tar *.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。\\# tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。\\# tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。\\# tar -tf all.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思\\# tar -xf all.tar这条命令是解出all.tar包中所有文件，-t是解开的意思**总结**1、*.tar 用 tar -xvf 解压2、*.gz 用 gzip -d或者gunzip 解压3、*.tar.gz和*.tgz 用 tar -xzf 解压4、*.bz2 用 bzip2 -d或者用bunzip2 解压5、*.tar.bz2用tar -xjf 解压6、*.Z 用 uncompress 解压7、*.tar.Z 用tar -xZf 解压8、*.rar 用 unrar e解压9、*.zip 用 unzip 解压gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为&quot;.gz&quot;。 cp Make.Linux_Intel64 . 静态链接库与动态链接库所谓静态链接库，说白了就是在你把写好的代码编译的时候，就把你引用的库一起给编进去了，从此后你编出来的执行程序跟外面都不再有任何关系，即使这个库更新了，你也搭不上边儿，其次，如果系统中许多类似的程序都需要用到这个库，那么各自在编译的时候都需要把这个库给编进去，浪费存储空间（加载到内存里应该也是浪费内存空间的）。linux系统中静态库的名字一般叫xxx.a, 所以如果你看到一个以 .a结束的文件那么它多半就是一个静态链接库文件。 所谓动态链接库，也就是说编译的时候不会真的把你引用到的库给编到你的执行程序里，而是在执行时候才会去加载相关的库，所有用到此库的程序可以共享一份代码，这样带来的好处是可执行程序所占的空间变小了，同时，如果库需要升级，你并不需要重新编译你的程序，只要把相关的库升级即可。 在linux下动态链接库文件一般叫做libxxx.so。 ln命令1234567891011121314151617181920212223这是linux中一个非常重要命令，请大家一定要熟悉。它的功能是为某一个文件或目录在另外一个位置建立一个同步的链接，类似Windows下的超级链接。这个命令最常用的参数是-s，具体用法是：sudo ln -s 源文件 目标文件 举例：当前目录是/local，而我经常要访问/usr/local/linux/work那么我就可以使用在local下建立一个文件linkwork，然后sudo ln -s /usr/local/linux/work /local/linkwork即建立两者之间的链接。删除链接rm -rf symbolic_name 注意不是rm -rf symbolic_name/ 那么上面我就是rm -rf /local/linkwork链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。 在硬链接的情况下，参数中的“目标”被链接至[链接名]。如果[链接名]是一个目录名，系统将在该目录之下建立一个或多个与“目标”同名的链接文件， 链接文件和被链接文件的内容完全相同。如果[链接名]为一个文件，用户将被告知该文件已存在且不进行链接。如果指定了多个“目标”参数，那么最后一个参数 必须为目录。 如果给ln命令加上- s选项，则建立符号链接。如果[链接名]已经存在但不是目录，将不做链接。[链接名]可以是任何一个文件名（可包含路径），也可以是一个目录，并且允许它与“目标”不在同一个文件系统中。如果[链接名]是一个已经存在的目录，系统将在该目录下建立一个或多个与“目标”同名的文件，此新建的文件实际上是指向原“目标”的符号链接文件 查找文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283在使用linux时，经常需要进行文件查找。其中查找的命令主要有find和grep。两个命令是有区的。 区别：(1)find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 (2)grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。 (3)which 查看可执行文件的位置 ，只有设置了环境变量的程序才可以用 (4)whereis 寻找特定文件，只能用于查找二进制文件、源代码文件和man手册页 (5)locate 配合数据库查看文件位置 ,详情：locate -h查看帮助信息 一.find命令 基本格式：find path expression 1.按照文件名查找 (1)find / -name httpd.conf #在根目录下查找文件httpd.conf，表示在整个硬盘查找 (2)find /etc -name httpd.conf #在/etc目录下文件httpd.conf (3)find /etc -name '*srm*' #使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件 (4)find . -name 'srm*' #表示当前目录下查找文件名开头是字符串‘srm’的文件 2.按照文件特征查找 (1)find / -amin -10 # 查找在系统中最后10分钟访问的文件(access time) (2)find / -atime -2 # 查找在系统中最后48小时访问的文件 (3)find / -empty # 查找在系统中为空的文件或者文件夹 (4)find / -group cat # 查找在系统中属于 group为cat的文件 (5)find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件(modify time) (6)find / -mtime -1 #查找在系统中最后24小时里修改过的文件 (7)find / -user fred #查找在系统中属于fred这个用户的文件 (8)find / -size +10000c #查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB) (9)find / -size -1000k #查找出小于1000KB的文件 3.使用混合查找方式查找文件 参数有： ！，-and(-a)，-or(-o)。 (1)find /tmp -size +10000c -and -mtime +2 #在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件 (2)find / -user fred -or -user george #在/目录下查找用户是fred或者george的文件文件 (3)find /tmp ! -user panda #在/tmp目录中查找所有不属于panda用户的文件 二、grep命令 基本格式：find expression 1.主要参数 [options]主要参数： －c：只输出匹配行的计数。 －i：不区分大小写 －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及行号。 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 pattern正则表达式主要参数： \\： 忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 : 匹配正则表达式的结束行。 \\&lt;：从匹配正则表达 式的行开始。 \\&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如[A]即A符合要求 。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。 .：所有的单个字符。 * ：有字符，长度可以为0。 2.实例 grep -r &quot;字符串&quot; 很方便 (1)grep 'test' d* #显示所有以d开头的文件中包含 test的行 (2)grep ‘test’ aa bb cc #显示在aa，bb，cc文件中包含test的行 (3)grep ‘[a-z]\\{5\\}’ aa #显示所有包含每行字符串至少有5个连续小写字符的字符串的行 (4)grep magic /usr/src #显示/usr/src目录下的文件(不含子目录)包含magic的行 (5)grep -r magic /usr/src #显示/usr/src目录下的文件(包含子目录)包含magic的行 (6)grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)， man命令123456789man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。 语法 man+（选项）+参数选项 -a：在所有的man帮助手册中搜索； -f：等价于whatis指令，显示给定关键字的简短描述信息； -P：指定内容时使用分页程序； -M：指定man手册搜索的路径。 top命令1234567891011121314151617181920212223242526272829303132top 命令实时显示进程的状态。默认状态显示的是cpu密集型的进程，并且每5秒钟更新一次。你可以通过PID的数字大小，age (newest first), time (cumulative time),resident memory usage（常驻内存使用）以及进程从启动后占用cpu的时间。PID: 进程描述符 USER： 进程的拥有者 PRI：进程的优先级 NI： nice level SIZE: 进程拥有的内存（包括code segment + data segment + stack segment） RSS: 物理内存使用VIRT（virtul memory usage）: 进程需要的虚拟内存大小RES(resident memory usage)： 常驻内存 SHARE: 和其他进程共享的物理内存空间 STAT：进程的状态，有 S=sleeping，R=running，T=stopped or traced，D=interruptible sleep（不可中断的睡眠状态），Z=zombie。 %CPU： CPU使用率 %MEM： 物理内存的使用TIME： 进程占用的总共cpu时间 COMMAND：进程的命令 t: 用于是否显示总的统计数据（关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示） l – 关闭或开启第一部分第一行 top 信息的表示 m：用户是否显示内存的信息（关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示） A： 根据单窗口切换成多窗口，可以看到四个不同的窗口，可以通过a或者w来切换多个窗口。 四个窗口的名字分别为：Def，Job，Mem，Usr f：进入一个动态配置top的screen中，可以根据自己的喜好配置topo：对top的现有配置排序（order）r：使用renice命令k：使用kill命令 sudo ldconfig1234567891011121314151617181920212223ldconfig是一个动态链接库管理命令，其目的为了让动态链接库为系统所共享。ldconfig的主要用途：默认搜寻/lilb和/usr/lib，以及配置文件/etc/ld.so.conf内所列的目录下的库文件。搜索出可共享的动态链接库，库文件的格式为：lib***.so.**，进而创建出动态装入程序(ld.so)所需的连接和缓存文件。缓存文件默认为/etc/ld.so.cache，该文件保存已排好序的动态链接库名字列表。ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。#ldconfig需要注意的地方：1、往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf文件的，但是添加完后需要调用下ldconfig，不然添加的library会找不到。2、如果添加的library不在/lib和/usr/lib里面的话，就一定要修改/etc/ld.so.conf文件，往该文件追加library所在的路径，然后也需要重新调用下ldconfig命令。比如在安装MySQL的时候，其库文件/usr/local/mysql/lib，就需要追加到/etc/ld.so.conf文件中。命令如下：# echo &quot;/usr/local/mysql/lib&quot; &gt;&gt; /etc/ld.so.conf# ldconfig -v | grep mysql3、如果添加的library不在/lib或/usr/lib下，但是却没有权限操作写/etc/ld.so.conf文件的话，这时就需要往export里写一个全局变量LD_LIBRARY_PATH，就可以了。 软件的安装与卸载12345678910111213141516171819202122232425262728293031323334353637383940414243444546一、Ubuntu中软件安装方法1、APT方式（1）普通安装：apt-get install softname1 softname2 …;（2）修复安装：apt-get -f install softname1 softname2... ;(-f Atemp to correct broken dependencies)（3）重新安装：apt-get --reinstall install softname1 softname2...;2、Dpkg方式（1）普通安装：dpkg -i package_name.deb3、源码安装（.tar、tar.gz、tar.bz2、tar.Z）首先解压缩源码压缩包然后通过tar命令来完成a．解xx.tar.gz：tar zxf xx.tar.gz b．解xx.tar.Z：tar zxf xx.tar.Z c．解xx.tgz：tar zxf xx.tgz d．解xx.bz2：bunzip2 xx.bz2 e．解xx.tar：tar xf xx.tar然后进入到解压出的目录中，建议先读一下README之类的说明文件，因为此时不同源代码包或者预编译包可能存在差异，然后建议使用ls -F --color或者ls -F命令（实际上我的只需要 l 命令即可）查看一下可执行文件，可执行文件会以*号的尾部标志。一般依次执行./configure make sudo make install即可完成安装。二、Ubuntu中软件包的卸载方法1、APT方式（1）移除式卸载：sudo apt-get remove softname1 softname2 …;（移除软件包，当包尾部有+时，意为安装）（2）清除式卸载：sudo apt-get purge sofname1 softname2...;(同上，也清除配置文件)2、Dpkg方式（1）移除式卸载：dpkg -r pkg1 pkg2 ...;（2）清除式卸载：dpkg -P pkg1 pkg2...; 常见 Shell :sh、bash、csh、tcsh、ash12345678910111213141516171819202122232425262728293031323334353637383940414243Shell 既是一种脚本编程语言，也是一个连接内核和用户的软件。常见的 Shell 有 sh、bash、csh、tcsh、ash 等。shsh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。sh 是 UNIX 上的标准 shell，很多 UNIX 版本都配有 sh。sh 是第一个流行的 Shell。cshsh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。Bill Joy 是一个风云人物，他创立了 BSD 操作系统，开发了 vi 编辑器，还是 Sun 公司的创始人之一。BSD 是 UNIX 的一个重要分支，后人在此基础上发展出了很多现代的操作系统，最著名的有 FreeBSD、OpenBSD 和 NetBSD，就连 Mac OS X 在很大程度上也基于BSD。tcshtcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。ash一个简单的轻量级的 Shell，占用资源少，适合运行于低内存环境，但是与下面讲到的 bash shell 完全兼容。bashbash shell 是 Linux 的默认 shell，本教程也基于 bash 编写。bash 由 GNU 组织开发，保持了对 sh shell 的兼容性，是各种 Linux 发行版默认配置的 shell。bash 兼容 sh 意味着，针对 sh 编写的 Shell 代码可以不加修改地在 bash 中运行。尽管如此，bash 和 sh 还是有一些不同之处：一方面，bash 扩展了一些命令和参数；另一方面，bash 并不完全和 sh 兼容，它们有些行为并不一致，但在大多数企业运维的情况下区别不大，特殊场景可以使用 bash 代替 sh。查看 ShellShell 是一个程序，一般都是放在/bin或者/user/bin目录下，当前 Linux 系统可用的 Shell 都记录在/etc/shells文件中。/etc/shells是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。通过 cat 命令来查看当前 Linux 系统的可用 Shell：$ cat /etc/shells/bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh在现代的 Linux 上，sh 已经被 bash 代替，/bin/sh往往是指向/bin/bash的符号链接。如果你希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量：$ echo $SHELL/bin/bash输出结果表明默认的 Shell 是 bash。 /usr/bin/env12345678910111213#!/usr/bin/env 在linux的一些bash的脚本，需在开头一行指定脚本的解释程序，如： #!/usr/bin/env python 再如： #!/usr/bin/env perl #!/usr/bin/env zimbu #!/usr/bin/env ruby 但有时候也用 #!/usr/bin/python 和 #!/usr/bin/perl 那么 env到底有什么用？何时用这个呢？ 脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。同时，env还规定一些系统环境变量。 #wc命令 123456789101112131415Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。-c 统计字节数。-l 统计行数。-m 统计字符数。这个标志不能与 -c 标志一起使用。-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。-L 打印最长行的长度。-help 显示帮助信息--version 显示版本信息 文件权限详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758文件权限ls -l中显示的内容如下：-rwxrw-r‐-1 root root 1213 Feb 2 09:39 abc- 10个字符确定不同用户能对文件干什么- 第一个字符代表文件（-）、目录（d），链接（l）- 其余字符每3个一组（rwx），读（r）、写（w）、执行（x）- 第一组rwx：文件所有者的权限是读、写和执行- 第二组rw-：与文件所有者同一组的用户的权限是读、写但不能执行- 第三组r--：不与文件所有者同组的其他用户的权限是读不能写和执行也可用数字表示为：r=4，w=2，x=1 因此rwx=4+2+1=7- 1 表示连接的文件数- root 表示用户- root表示用户所在的组- 1213 表示文件大小（字节）- Feb 2 09:39 表示最后修改日期- abc 表示文件名改变权限的命令chmod 改变文件或目录的权限chmod 755 abc：赋予abc权限rwxr-xr-xchmod u=rwx，g=rx，o=rx abc：同上u=用户权限，g=组权限，o=不同组其他用户权限chmod u-x，g+w abc：给abc去除用户执行的权限，增加组写的权限chmod a+r abc：给所有用户添加读的权限linux系统文件夹644、755、777权限设置详解 ，左至右，第一位数字代表文件所有者的权限，第二位数字代表同组用户的权限，第三位数字代表其他用户的权限。而具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示；通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）以755为例：第一位7等于4+2+1，rwx，所有者具有读取、写入、执行权限；第二位5等于4+1+0，r-x，同组用户具有读取、执行权限但没有写入权限；第三位5，同上，也是r-x，其他用户具有读取、执行权限但没有写入权限。 更改目录权限与所有者12345678910111213141516171819201、利用chmod修改权限：对Document/目录下的所有子文件与子目录执行相同的权限变更：chmod -R 700 Document/-R参数是递归 处理目录下的所有文件以及子文件夹700是变更后的权限表示（只有所有者有读和写以及执行的权限）Document/ 是需要执行的目录2、利用chown改变所有者：对Document/ 目录下的所有文件与子目录执行相同的所有者变更，修改所有者为users用户组的username用户sudo chown -R username:users Document/-R表示递归式地改变指定目录及其下的所有子目录和文件的拥有者。 username:users users用户组的username，用户组参数不是必须有 #g77、g95、gfortran区别 输出gcc预定义宏gcc -dM -E - &lt;&lt;&lt; ‘’ 或echo | gcc -dM -E -","link":"/2019/03/10/Linux%E7%AC%94%E8%AE%B0/"},{"title":"Shell命令结构和规范","text":"Shell命令结构和规范 Shell命令结构和规范Shell作为外围软件生态群其中一个非常重要的组件。它是操作系统最外层的接口，负责直接面向用户交互并提供内核服务，包括命令行接口(CLI)或图形界面接口(GUI)两种形式。以CLI为例，它提供一套命令规范，是一种解释性语言，将用户输入经过解释器(interpreter)输出使其转化成真正的系统调用，实现人机交互的功能。 命令结构和规范Thompson Shell命令语言结构和规范的基础，其解释器具有跨平台的可移植性，并影响到了后来包括Bourne Shell在内的各种脚本语言设计实现。Bourne Shell的5个特性和命令规范，可以通过sh(1)手册查看原始资料。 过滤器/管道线(filter/pipeline)。这绝对是要载入Unix史册的发明，创立者是Douglas McIlroy，Thompson Shell引入并实现了这个伟大的概念——一个或多个命令组成一根过滤器的链条，由’|’或’^’符号分隔。除最后一个命令之外，每个命令的标准输出都被作为下一个命令的标准输入。这样每个命令都作为一个独立的进程来运行，并通过管道与邻近的进程相连接。圆括弧内的命令序列整体上可以替代单个命令作为过滤器实现，比如用户可以输入”(A;B)|C”。 命令序列和后台进程。分号’;’指示多个命令序列化执行。’&amp;’符号指示该命令在后台异步执行，使得前面的管道线不必等待其终止，仅仅报告一个进程id，这样用户以后可以通过kill命令与它通信。有益于进程管理。 I/O重定向。它利用了Unix设计上的一个重要特性——一切皆文件，用三个符号表示：”重定向输出，如果文件不存在则创建它，如果文件存在则截断它；’&gt;&gt;’追加模式重定向输出，如果文件不存在则创建它，如果文件存在则追加输出至末尾处。 通配符扩展(globbing)。通配符的概念源自于正则表达式，使得解释器智能地处理用户不完全输入，比如记不清文件名、一次性输入多个文件等。’?’匹配任意单一字符；’*’匹配任意字符串（包括空串）；成对’[‘和’]‘定义了字符集合一个类，可匹配方括号内任意成员，用’-‘两端可指定一系列连续字符匹配范围。 参数传递。这里主要引入了位置参数和选项参数的概念：’$n’指示shell调用的第n个参数替代；还定义了两个选项参数’-t’和’-c’，前者用于交互，导致shell从标准输入中读入一行作为用户执行的系统命令，后者指示shell将附带的下一个参数作为命令执行（可正确处理换行符），是对’-t’的补充，特别是调用者已经读取了命令其中某些字符的情况下。如果不带选项参数则直接读取文件名。 通配符(wildcard) *: 代表任意个任意字符 ?: 代表1个任意字符 [abc]：代表a或b或c中的一个 [a-z]: 代表 a～z这个范围 [^abc] : 代表除了a或b或c以外的字符 数据流重定向： 0： STDIN 标准输入 1： STDOUT 标准输出 2： STDERR 标准错误输出 &gt;, &gt;&gt;: 输出流重定向， &gt; 为 覆盖，&gt;&gt; 为追加 cat infile 1&gt; outfile 2&gt;&amp;1 将 2 重定向到 1， 再将 1 重定向到 outfile 文件，意思是将标准错误输出和标准输出都存入outfile find /home 2&gt; /dev/null 将错误输出 /dev/null, /dev/null是垃圾黑洞，可以将信息忽略 &lt; : 输入重定向 cat &gt; catfile &lt; ~/test 用 test 文件的内容代替STDIN输入到 catfile里 &lt;&lt;: eof符号 cat &gt; catfile &lt;&lt; ‘eof’ 你可以使用STDIN（键盘输入）来输入到catfile，当输入eof时，输入结束，相当于点了 ctrl + d 命令执行依据 ; &amp;&amp; || ； ： 顺序执行 &amp;&amp; : 且 逻辑， cmdA &amp;&amp; cmdB, 只有cmdA成功了才会继续执行cmdB，成功的依据就是 $? 这个状态回传码 || : 或逻辑， cmdA || cmdB 只有cmdA执行失败才会继续执行cmdB 管道(pipe | ) 管道可以将前一个命令的stdout当作后一个命令的stdin，只有特定的管道命令才能使用 管道命令有 cut,grep,sort,wc,uniq,tee,tr,col,join,paste,expand等 而ls cd这些命令则不是管道命令，如果需要使用管道则需要用xargs作参数代换 - 号的用途 - 号可以代替 STDOUT STDIN tar -czv -f - /home | tar -xzv -f - 第一个 - 代替stdout，第二个 - 代替stdin，想当于用tar来实现cp 算数运算 $((a*b)) : 计算a与b的乘积，只支持整数 变量操作 使用export将自定义变量转为环境变量 “:” 表示并列含义，例如A变量值有多个，用：符号进行分离。","link":"/2019/03/10/Shell%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84%E5%92%8C%E8%A7%84%E8%8C%83/"},{"title":"Win10桌面美化教程","text":"电脑浏览效果更佳，详情请点击“展开全文”。 一、任务栏全透明与开始菜单美化先上效果。 下载StartisBack软件： 从官网下载的只有30天试用期，我们下载破解版的。→下载地址及软件简介 我从B站上找了一个安装视频：https://www.bilibili.com/video/av8723545/ 对网站里面的介绍补充几点： 开始菜单的图标由于网站找不到了，我就把我之前下载的找了出来放在百度网盘了： 链接: https://pan.baidu.com/s/1RFr4K-t0pS0D4bsYt7y_UQ 密码: hu4q 修改图标的方法：点击上图中的加号，选择想要更换的图标文件，然后在软件里面选择即可。 二、快捷方式美化 首先我们可以使用电脑管家的“桌面整理”功能进行桌面简化。 但是会发现这个仅仅是桌面东西少了，并不是特别好看。 所以，我们又要使用软件了，他就是：RocketDock（仿Mac OS X Yosemite Dock栏），官网下载 能从网上找就不自己说的软件简介 动态演示： 推荐一款我正在使用的主题：里面很多细节，可以自己摸索一下，根据自己的喜好设置。 ![q9fra.png](https://s1.ax2x.com/2018/07/11/q9fra.png) 三、快捷方式隐藏与管理MadAppLauncher是一个非常实用的应用程序快速启动工具。*让你的桌面成为真正的空白而又不失方便性。记得添加快捷方式后要保存哟，这个软件其实是把快捷方式索引放入一个文件里面，然后软件开启时加载这个文件，这里是D:\\桌面\\快捷方式\\1.mal文件，可以用记事本打开这个文件，就大致知道了。 详细介绍及使用说明见:百度百科 点我下载 如有疑问，请联系qq:1421692663.","link":"/2018/09/08/Win10%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"},{"title":"Windows软件及手机App推荐","text":"安利一些自己使用过的提高效率与体验的软件！ Windows：1、Listary - 能极大幅度提高你 Windows 文件浏览与搜索速度效率的「超级神器」 官网及简介 2、QuickLook - 一款即时预览工具 按下空格即可快速预览文件，微软商店内的免费应用。 3、Ditto - 一款剪切板工具 百度百科简介：Ditto 是一款强大的 Windows 剪贴板增强工具，它支持64位操作系统，而且完全免费，绿色开源，支持中文，而且还有免安装的绿色版本。 开启 Ditto 后，不会有任何程序界面出现，它只是默默地在系统右下角弹出了一个蓝色的托盘图标，这时候你复制任何内容到剪贴板都会被 Ditto 一一记录。如果你什么时候想找到它，就可以按 Ctrl+`，当中的每条内容都可以供你选择性的重新复制。 下载地址 4、Typora - win平台最好用的Markdown工具，所见即所得。 这个博客的所有文章都是用它完成的。UI真心好看。 官网下载 5、BandZIP - win平台最好的压缩软件，无广告，速度快，绝对首选。 官网下载 6、欧陆词典 - 目前本人找到的最好用的专业性与普适性并存的词典，搭配专业术语词库食用简直不要太香。词库可在官网搜索下载。 官网 但是导入词库需要收费，所以找了个破解文件，连同计算机专业词汇词库一块打包分享了， 点我下载破解文件及词库 App：1、夸克浏览器 - UC团队温情出品，无广告，UI巨好看，界面简洁。 2、微博国际版 - 无广告，界面舒服，用的人都说好。 3、超级计算器 - 我是从华为应用市场里面下载的，目前见过最好用的计算器，不管公式多长，还能求积分，画简单的图象。 4、腾讯文件 - 这个相信很多同学都没听说吧，这个腾讯官方出的app可以管理QQ和微信的所有文件，比任何的垃圾清理软件都好用。如果对这个软件有什么建议还可以加官方QQ群：713760127 5、多看阅读/掌阅 - 这俩经常用手机看电子书的应该都知道，很多功能很人性化。 6、便签 - 我也是用遍了华为应用市场里面的所有便签软件，最后只留下了这个，支持绑定并同步印象笔记，还可以放在手机桌面，而且支持markdown，直接生成图片。 7、倒数日 - 每到期末考试的时候，用这个提醒自己很方便了，虽然自带的日历用着也不错。 如有疑问，请QQ联系：1421692663","link":"/2018/09/08/Windows%E8%BD%AF%E4%BB%B6%E5%8F%8A%E6%89%8B%E6%9C%BAApp%E6%8E%A8%E8%8D%90/"},{"title":"《Core Java》读书笔记","text":"《Java核心技术 ·卷Ⅰ(原书第10版)》读书笔记！ field，域是一种属性，可以是一个类变量，一个对象变量，一个对象方法变量或者是一个函数的参数。（补充，class‘s variables，类的实例变量和静态变量称为class’s variables，类属变量，也称类变量或数据域，其实翻译成属性也可以，类属性，听起来不会怪怪的，来自百度百科）。 Java中的域说的就是类的成员变量,也叫属性,不是方法,还有对成员变量的操作要放在方法中. 类变量：在java中，类变量（也叫静态变量）是类中独立于方法之外的变量，用static 修饰。（static表示“全局的”、“静态的”，用来修饰成员变量和成员方法，或静态代码块（静态代码块独立于类成员，jvm加载类时会执行静态代码块，每个代码块只执行一次，按顺序执行））。 类变量：（静态变量）独立于方法之外的变量，用 static 修饰。（C++解释：类中定义的静态变量，这个变量属于这个类，为所有对象共有，所以叫类变量） 局部变量：类的方法中的变量。（C++解释：函数成员里面定义的变量） 实例变量：（全局变量、对象变量）：独立于方法之外的变量，不过没有 static 修饰。（C++解释：类中的数据成员，即实例域） 参考资料 java中的变量分为2种：一种是成员变量，一种是局部变量。 成员变量是在类内定义的变量，成员变量有分为两种，如果是用static修饰的就是静态变量或者叫类变量；没有被static修饰就是非静态变量或者叫实例变量。 局部变量包括3种：方法的形参，通过方法的调用进行赋值，并随着方法的结束而结束；方法内的局部变量，必须在方法内对其进行显式的初始化，随着方法的结束而结束；代码块内的局部变量，随着的初始化完成后开始生效，随着代码块的结束而结束。 静态工厂方法 创建类的实例的最常见的方式是用new语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条new语句，都会导致Java虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。 例如Class实例是Java虚拟机在加载一个类时自动创建的，程序无法用new语句创建java.lang.Class类的实例，因为Class类没有提供public类型的构造方法。为了使程序能获得代表某个类的Class实例，在Class类中提供了静态工厂方法forName(String name)，它的使用方式如下： Class c=Class.forName(“Sample”); //返回代表Sample类的实例 静态工厂方法与用new语句调用的构造方法相比，有以下区别。 （1）构造方法的名字必须与类名相同。这一特性的优点是符合Java语言的规范，缺点是类的所有重载的构造方法的名字都相同，不能从名字上区分每个重载方法，容易引起混淆。 静态工厂方法的方法名可以是任意的，这一特性的优点是可以提高程序代码的可读性，在方法名中能体现与实例有关的信息 这一特性的缺点是与其他的静态方法没有明显的区别，使用户难以识别类中到底哪些静态方法专门负责返回类的实例。为了减少这一缺点带来的负面影响，可以在为静态工厂方法命名时尽量遵守约定俗成的规范，当然这不是必需的。目前比较流行的规范是把静态工厂方法命名为valueOf或者getInstance。 l valueOf：该方法返回的实例与它的参数具有同样的值，例如： Integer a=Integer.valueOf(100); //返回取值为100的Integer对象 从上面代码可以看出，valueOf()方法能执行类型转换操作，在本例中，把int类型的基本数据转换为Integer对象。 l getInstance：返回的实例与参数匹配，例如： //返回符合中国标准的日历 Calendar cal=Calendar.getInstance(Locale.CHINA); （2）每次执行new语句时，都会创建一个新的对象。而静态工厂方法每次被调用的时候，是否会创建一个新的对象完全取决于方法的实现。 （3）new语句只能创建当前类的实例，而静态工厂方法可以返回当前类的子类的实例，这一特性可以在创建松耦合的系统接口时发挥作用，参见本章11.3.5节（松耦合的系统接口）。 静态工厂方法最主要的特点是：每次被调用的时候，不一定要创建一个新的对象。利用这一特点，静态工厂方法可用来创建以下类的实例。 l 单例类：只有惟一的实例的类。 l 枚举类：实例的数量有限的类。 l 具有实例缓存的类：能把已经创建的实例暂且存放在缓存中的类。 l 具有实例缓存的不可变类：不可变类的实例一旦创建，其属性值就不会被改变。 在下面几节，将结合具体的例子，介绍静态工厂方法的用途。 11.3.1 单例（singleton）类 单例类是指仅有一个实例的类。在系统中具有惟一性的组件可作为单例类，这种类的实例通常会占用较多的内存，或者实例的初始化过程比较冗长，因此随意创建这些类的实例会影响系统的性能。 Tips 熟悉Struts和Hibernate软件的读者会发现，Struts框架的ActionServlet类就是单例类，此外，Hibernate的SessionFactory和Configuration类也是单例类。 例程11-6的GlobalConfig类就是个单例类，它用来存放软件系统的配置信息。这些配置信息本来存放在配置文件中，在GlobalConfig类的构造方法中会从配置文件中读取配置信息，并把它存放在properties属性中。 参考资料 java中的final与C++中的const的区别(1)final在java中定义常量，可作用于基本类型或者类类型，若是作用于类类型，则此类类型不能作为父类被继承，也就是说它的下面不能有子类，这样的类叫做原子类。 C＋＋中的const定义常量， (2)Java中的final如果是对于基本类型，那和C++ const是一样的 但是如果是对对象而言，不同了 (3)final表示这个句柄是不可改变的 final Object obj=(Object)new String(“a”); obj=(Object)new String(“hello”);是非法的 但是依然可以调用obj的方法。如((String)obj).length()是合法的 而C++如果一个对象被定义成const，就不能调用对象的方法。除非这个方法被定义成const. 1234567891011121314package test;/*final表示这个句柄是不可改变的 final Object obj=(Object)new String(&quot;a&quot;); obj=(Object)new String(&quot;hello&quot;);是非法的 但是依然可以调用obj的方法。如((String)obj).length()是合法的 */public class Test { public static void main(String[] args) { final Object obj=(Object)new String(&quot;a&quot;); //obj=(Object)new String(&quot;hello&quot;);//不能对终态局部变量obj赋值 System.out.println(((String)obj).length());//但是依然可以调用obj的方法 }} final,static,const在使用上有什么区别 final: final修饰类：该类不可继承 final修饰方法：该方法不能被子类覆盖（但它不能修饰构造函数） final修饰字段属性：属性值第一次初始化后不能被修改 使用final可以提高程序执行的效率，将一个方法设成final后编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。 static: static修饰成员函数则该函数不能使用this对象 static不能修饰构造函数、函数参数、局部成员变量 static修饰成员字段则当类被虚拟机加载时按照声明先后顺序对static成员字段进行初始化。 static修饰语句块：当类被虚拟机加载时按照声明先后顺序初始化static成员字段和static语句块 static所修饰的方法和字段只属于类，所有对象共享，java不能直接定义全局变量，是通过static来实现的。 java中没有const，不能直接定义常量，是通过static final组合来实现的。 https://blog.csdn.net/yiziweiyang/article/details/52317330 浅析Java中的final关键字https://www.cnblogs.com/dolphin0520/p/3736238.html 构造器和方法的区别一般我们讲的“函数”就是“方法”； 构造函数=构造方法； 有些地方还将它称为构造子、构造器。 一般情况下，我们叫它构造函数或者构造方法。 https://blog.csdn.net/zqixiao_09/article/details/50550035 字面量、常量、变量字面量是指由字母，数字等构成的字符串或者数值，它只能作为右值出现，所谓右值是指等号右边的值，如：int a=123这里的a为左值，123为右值。 常量和变量都属于变量，只不过常量是赋过值后不能再改变的变量，而普通的变量可以再进行赋值操作。 return：结束此方法 break：跳出此循环 //for each输出二维数组，看成数组的数组 for(int[] row : a) { for(int b : row) System.out.printf(“%4d”, b);} 一个Java源文件中最多只能有一个public类，当有一个public类时，源文件名必须与之一致，否则无法编译，如果源文件中没有一个public类，则文件名与类中没有一致性要求。至于main()不是必须要放在public类中才能运行程序。 如果一个类定义在某个包中，那么package语句应该在源文件的首行。 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 Java中所有继承都是公有继承。==与equals==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。 equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。 ==比较的是2个对象的地址，而equals比较的是2个对象的内容。 详细解释 关于Java引用类型变量 基本数据类类型存的是数值本身，而引用类型变量在内存放的是数据的引用，并不是数据的本身，引用类型变量是以间接方式去获取数据。引用类型变量都属于对象类型，如：数组、类、字符串等都属于引用类型变量。所以，引用类型变量里面存放的是数据的地址。 比如：String s = new String();这个其实是在栈内存里分配一块内存空间为s，在堆内存里new了一个String类型的空间，在运行时是 栈内存里的 s 指向堆内存里的那一块存储空间 参考 Java中的语法糖lang -&gt;languagejava.lang包是Java语言的核心类库，包括了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等。每个Java程序运行时，系统都会自动地引入java.lang包，所以这个包的加载是缺省的。 Java4Android视频笔记 一个引用能够调用哪些成员（变量和函数），取决于这个引用的类型 一个引用调用的是哪一个方法，取决于这个引用所指向的对象 抽象类可以有构造函数，因为子类调用它自己的构造函数时必定会调用父类的构造函数。 public：可以修饰类、成员变量、和成员函数，同一个包当中，或者不同包当中的类都可以访问（前面需要加包名） private：可以修饰成员变量、成员函数，只能在本类当中使用 default（默认权限）：可以修饰类、成员变量、和成员函数，包权限：只能在本包中使用public&gt;protected&gt;default&gt;private 接口当中的方法都是抽象方法、public权限","link":"/2018/09/08/core%20Java%E7%AC%94%E8%AE%B0/"},{"title":"csv文件数据操作函数总结","text":"在C++课程设计中，由于采用了csv格式存储数据，故对文件操作涉及较多，在此总结一下csv文件格式的数据处理函数。 ####C++文件流 流，简单来说就是建立在面向对象基础上的一种抽象的处数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向。流不但可以处理文件，还可以处理动态内存、网络数据等多种数据形式。如果你对流的操作非常熟练，在程序中利用流的方便性，写起程序会大大提高效率的。 ####文件操作 以下类型需要包含头文件 &lt; fstream&gt; ofstream 输出流：是从内存（控制台）读到硬盘;ifstream 输入流：是从硬盘读到内存（控制台）.fstream 文件流：是可对打开的文件进行读写操作. 打开文件的方式 在类ios(是所有流式I/O类的基类)中定义，常用的值如下： ios::app 文件不存在则创建, 在原文件内容后写入新的内容，app即单词 [append：附加] 的缩写。 ios::ate 文件打开后定位到文件尾，ios:app就包含有此属性 ios::binary 以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文 ios::in 文件以输入方式打开（文件数据输入到内存）,文件不存在则创建(ifstream默认的打开方式) ios::out 文件以输出方式打开（内存数据输出到文件）, 文件不存在则创建，若文件已存在则清空原内容(ofstream默认的打开方式) 以下几个不常用： ios::nocreate 不建立文件，所以文件不存在时打开失败 ios::noreplace 不覆盖文件，所以打开文件时如果文件存在失败 ios::trunc 如果文件存在，把文件长度设为0 关闭文件：file.close(); //与new之后要delete一样，打开文件后必须关闭文件 例：ifstream file(“d:\\\\date.csv”,ios::app); //路径名中的\\要双写 ####使用函数： 1234567 ch = file.get(); //去读一个字符，然后才能用eof判断是否为空 if(file.eof()) //如果 一个字符都未读到，表示文件为空 { .... }//eof()函数要跟在读取语句后，用来判断是否读到文件结束符EOF。原因为：//要清楚&quot;文件结束符&quot;(0xff).就是说我们文件最后的字符不是文件结束符,而最后的字符的下一位才是.所以操作再读多一次. 参考资料 ####操作文件指针 123456789101112131415161718192021222324252627//ifstream和ofstream都提供了成员函数来重定位文件定位指针（文件中下一个被读取或写入的字节号）//在ifstream中 这个成员函数为seekg（&quot;seek get&quot;）;在ofstream中为seekp（&quot;seek put&quot;）//输入流操作seekg(绝对位置); //绝对移动， seekg(相对位置,参照位置); //相对操作tellg(); //返回当前指针位置//输出流操作seekp(绝对位置); //绝对移动， seekp(相对位置,参照位置); //相对操作tellp()和tellg()成员函数分别用来返回当前get和put的指针位置参照位置：ios::beg //相对于文件头ios::cur //相对于当前位置ios::end //相对于文件尾 例： file.seekg(0,ios::end); //参照位置为文件结束处，相对位置为0，即相对于文件尾移动0，于是指针定位在文件结束处 ​ file.seekg(0,ios::beg); //基地址为文件头，偏移量为0，于是定位在文件头 参考资料 string函数 getline（）函数 getline()的原型是istream&amp; getline ( istream &amp;is , string &amp;str , char delim ); 其中 istream &amp;is 表示一个输入流，譬如cin；string&amp;str表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以）；char delim表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为’\\n’，也就是回车换行符（遇到回车停止读入）。 参考资料 s.erase()函数 erase函数的原型如下： （1）string&amp; erase ( size_t pos = 0, size_t n = npos ); （2）iterator erase ( iterator position ); （3）iterator erase ( iterator first, iterator last ); 也就是说有三种用法： （1）erase(pos,n); 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符 （2）erase(position);删除position处的一个字符(position是个string类型的迭代器) （3）erase(first,last);删除从first到last之间的字符（first和last都是迭代器） 123456789101112131415string str (&quot;This is an example phrase.&quot;); string::iterator it; // 第(1)种用法 str.erase (10,8); cout &lt;&lt; str &lt;&lt; endl; // &quot;This is an phrase.&quot; // 第(2)种用法 it=str.begin()+9; str.erase (it); cout &lt;&lt; str &lt;&lt; endl; // &quot;This is a phrase.&quot; // 第(3)种用法 str.erase (str.begin()+5, str.end()-7); cout &lt;&lt; str &lt;&lt; endl; // &quot;This phrase.&quot; 参考资料 atoi()与stoi()函数 atoi：表示 ascii to integer，C语言函数，包含在头文件 stoi：表示 string to integer，包含在头文件 二者作用均为把字符串转换为int.在使用Dev-C++编译时，在编译选项中已选iso C++11选项但仍然出错，必须在编译时加入如下指令：-std=c++11。使用VS2017 不同的是atoi()的参数是 const char* ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char类型的,而stoi()的参数是const string,不需要转化为 const char*； stoi函数默认要求输入的参数字符串是符合int范围的[-2147483648, 2147483647]，否则会runtime error。atoi函数则不做范围检查，若超过int范围，则显示-2147483648（溢出下界）或者2147483647（溢出上界）。 参考资料1 参考资料2 参考资料3 参考资料4 itoa()函数 itoa表示：integer to array，是广泛应用的非标准C语言和C++语言扩展函数。由于它不是标准C/C++语言函数，所以不能在所有的编译器中使用。但是，大多数的编译器（如Windows上的）通常在&lt;stdlib.h&gt;/头文件中包含这个函数。 功能：将任意类型的数字转换为字符串。在&lt;stdlib.h&gt;中与之有相反功能的函数是atoi。 char *itoa( int value, char * string,int radix); 原型说明： value：欲转换的数据。 string：目标字符串的地址。 radix：转换后的进制数，可以是10进制、16进制等。 例：itoa(nu,str,10); //将nu转换为字符串并赋给str，第三个参数采用十进制。 参考资料 replace()函数 此函数常用方法有九种，这里简单介绍第一种，其他方法见参考资料： string&amp; replace (size_t pos, size_t len, const string&amp; str) 用str 替换指定字符串从起始位置pos开始长度为len 的字符 例：s.replace(s.find(“,”),1,”\\t”); //在字符串s中查找第一个逗号，然后把逗号换成\\t 参考资料 find()函数 所有重载函数： PS：网上关于以下函数的返回类型有int、size_type、size_t int find(char c, int pos = 0) const; //从pos开始查找字符c在当前字符串的位置int find(const char *s, int pos = 0) const; //从pos开始查找字符串s在当前串中的位置int find(const char *s, int pos, int n) const; //从pos开始查找字符串s中前n个字符在当前串中的位置int find(const string &amp;s, int pos = 0) const; //从pos开始查找字符串s在当前串中的位置 int find_first_of(char c, int pos = 0) const; //从pos开始查找字符c第一次出现的位置 //从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置int find_first_of(const char *s, int pos = 0) const; int find_first_of(const char *s, int pos, int n) const;int find_first_of(const string &amp;s,int pos = 0) const; 共同点： 查找成功时返回所在位置，失败返回string::npos的值，string::npos一般是MAX_INT（即2^32 - 1） 差异： find(): 查找字符串中第一次出现字符c、字符串s的位置； find_first_of(): 查找字符串中字符c、字符数组s中任意一个字符第一次出现的位置。 以上所讲的所有的string查找函数，都有唯一的返回类型，那就是size_type，即一个无符号整数（按打印出来的算）。若查找成功，返回按查找规则找到的第一个字符或子串的位置；若查找失败，返回npos，即-1（打印出来为4294967295）。 现区分size_type、size_t： 为了使自己的程序有很好的移植性，c++程序员应该尽量使用size_t和size_type而不是int, unsigned size_t是全局定义的类型；size_type是STL类中定义的类型属性，用以保存任意string和vector类对象的长度 string::size_type 制类型一般就是unsigned int, 但是不同机器环境长度可能不同 win32 和win64上长度差别;size_type一般也是unsigned int 使用的时候可以参考： string::size_type a =123; vectorsize_type b=234; size_t b=456; size_t 使用的时候头文件需要 ；size_type 使用的时候需要或者 sizeof(string::size_type) ​ sizeof(vector::size_type) sizeof(vector::size_type) sizeof(size_t) 上述长度均相等，长度为win32:4 win64:8 二者联系：在用下标访问元素时，vector使用vector::size_type作为下标类型，而数组下标的正确类型则是size_t 例：std::string::size_type posA = s.find(a); //使用size_type容器 ， if (posA != std::string::npos) //如果s字符串中存在a，即posA不是npos {….} 参考资料1 参考资料2 resize()函数 1、resize(n)调整容器的长度大小，使其能容纳n个元素。如果n小于容器的当前的size，则删除多出来的元素。否则，添加采用值初始化的元素。2、 resize(n，t)多一个参数t，将所有新添加的元素初始化为t。 参考资料 peek()函数 功能：peek函数用于读取并返回下一个字符，但并不提取该字符到输入流中，也就是说，依然让该字符作为将要提取到输入流的下一个字符。 例： if(file.peek() == EOF) //如果文件指针下一个字符为EOF，即读到文件尾。{….} 参考资料","link":"/2018/06/20/csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/02/21/hello-world/"},{"title":"《Shell 教程-菜鸟教程》笔记","text":"《Shell 教程-菜鸟教程》笔记 简单语法、命令#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 echo 命令用于向窗口输出文本。 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 echo -e 处理转义字符，开启转义 echo -n 不换行输出，或在字符串末尾加\\c 不换行 bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。自加操作：let no++ 、let a=5+4 #知识点 为什么./test.sh，而不是 test.sh./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 shell三种变量三种变量： 1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 ###csh与bash不同 123456789csh中$status与shell中$？含义相同：表示上个命令的退出状态，或函数的返回值。csh：setenv FILTERSFILTERBIN.RES#通过此函数并不能添加或修改 shell 进程的环境变量，或者说通过setenv函数设置的环境变量只在本进程，而且是本次执行中有效。如果在某一次运行程序时执行了setenv函数，进程终止后再次运行该程序，上次的设置是无效的，上次设置的环境变量是不能读到的。bash：export FILTERS=FILTERBIN.RES#export设置环境变量是暂时的，只在本次登录中有效，可修改如下文件来使命令长久有效。 #基本语法 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=&quot;qinjx&quot;echo $your_nameecho ${your_name} #变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界 使用 unset 命令可以删除变量(unset 命令不能删除只读变量)。语法： 1unset variable_name 获取字符串长度 12string=&quot;abcd&quot;echo ${#string} #输出 4 提取子字符串 123# 以下实例从字符串第 2 个字符开始截取 4 个字符：string=&quot;runoob is a great site&quot;echo ${string:1:4} # 输出 unoo 查找子字符串 1234# 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4# 以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。 读取数组 123456# 读取数组元素值的一般格式是：${数组名[下标]}# 例如：valuen=${array_name[n]}# 使用 @ 符号可以获取数组中的所有元素，例如：echo ${array_name[@]} 获取数组的长度 1234567# 获取数组长度的方法与获取字符串长度的方法相同，例如：# 取得数组元素的个数length=${#array_name[@]}# 或者length=${#array_name[*]}# 取得数组单个元素的长度lengthn=${#array_name[n]} 多行注释 1234567# 多行注释还可以使用以下格式：:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF# EOF 也可以使用其他符号:例如` ！ Shell 传递参数 1我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数， **$0** 为执行的文件名。以此类推…… 算术运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)： 1234#!/bin/bashval=`expr 2 + 2`echo &quot;两数之和为 : $val&quot; 3.显示变量 read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量 1234567#!/bin/shread name echo &quot;$name It is a test&quot;#以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:[root@www ~]# sh test.shOK #标准输入OK It is a test #输出 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 * 乘法，乘号前必须有\\ expr $a \\* $b 结果为 200。 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [$a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的&gt;，如果是，则返回 true。 [$a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的&lt;，如果是，则返回 true。 [$a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [$a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [$a -le $b ] 返回 true。 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true -o 或运算，有一个表达式为 true 则返回 true。 [$a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 = 检测两个字符串是否相等，相等返回 true。 [$a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 条件表达式要放在方括号之间，并且要有空格** test命令文件测试 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 函数shell中函数的定义格式如下： 123456789[ function ] funname [()]{ action; [return int;]} 说明： 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255 函数返回值在调用该函数后通过 $? 来获得。 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 带参数的函数示例： 1234567891011121314151617181920#!/bin/bashfunWithParam(){ echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 ${10} !&quot; echo &quot;第十一个参数为 ${11} !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;}funWithParam 1 2 3 4 5 6 7 8 9 34 73#输出结果：第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 #重定向命令列表如下： 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 Shell 文件包含和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。 Shell 文件包含的语法格式如下：（类似include语句） 123. filename # 注意点号(.)和文件名（完整文件名即路径+文件名）中间有一空格#或source filename Shell中判断语句if中-z至-d的意思12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[ -a FILE ] 如果 FILE 存在则为真。[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。[ -d FILE ] 如果 FILE 存在且是一个目录则为真。[ -e FILE ] 如果 FILE 存在则为真。[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。[ -r FILE ] 如果 FILE 存在且是可读的则为真。[ -s FILE ] 如果 FILE 存在且大小不为0则为真。[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。[ -x FILE ] 如果 FILE 存在且是可执行的则为真。[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。[ -z STRING ] “STRING” 的长度为零则为真。[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。[ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。[ STRING1 != STRING2 ] 如果字符串不相等则为真。[ STRING1 &lt; STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。[ STRING1 &gt;","link":"/2019/03/10/%E3%80%8AShell%20%E6%95%99%E7%A8%8B-%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"学习之路","slug":"学习之路","link":"/categories/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/categories/C/"}]}